#version 460
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_EXT_shader_atomic_int64 : enable
#extension GL_KHR_vulkan_glsl : enable
#include "utility_common.glsl"
#include "vertex_precision_common.glsl"

layout(set = 0, binding = 0) uniform Camera{
    mat4 view;
    mat4 projection;
    vec3 direction;
    vec3 position;
    uvec2 resolution;
}camera;

layout(set = 0, binding = 1) uniform DynamicConst{
    uint workerCount;
};

layout(set = 1, binding = 0) buffer RENDER_TARGET{
    uint64_t renderTarget[];
};

layout(set = 1, binding = 1, r32ui) uniform uimage2D depthBuffer;

// Vertex Precision Buffers are in vertex_precision_common file

layout(set = 2, binding = 3) buffer Points_Color{
    uint pointsRgba[];
};

layout(set = 3, binding = 0) readonly buffer Batches{
    Batch batches[];  
};

layout(set = 3, binding = 1) readonly buffer BatchList{
    uint batchCount;
    uint batchList[];
};

layout(local_size_x = 128) in;

void main(){

    const uint id = gl_GlobalInvocationID.x;
    if (id >= workerCount){
        return;
    }

    const uint workAmount = uint(ceil(float(batchCount) / workerCount));
    const uint workOffset = workAmount * id;

    for (uint i = workOffset; i < workOffset + workAmount; ++i){
        if (i >= batchCount){
            continue;
        }
        const Batch batch = batches[batchList[i]];
        const vec3 batchBBSize = batch.box.maxV - batch.box.minV;
        const uint batchPixelExtend = getBatchPixelExtend(batch, camera.resolution, camera.projection, camera.view);

        for (uint k = batch.pointOffset; k < batch.pointOffset + batch.pointCount; ++k){

            const vec4 projected = camera.projection * camera.view * vec4(getAdaptivePointPosition(batchBBSize, batch.box.minV, batchPixelExtend, k), 1);

            if((-projected.w <= projected.x) && (projected.x <= projected.w) &&
                    (-projected.w <= projected.y) && (projected.y <= projected.w) &&
                    (0.f <= projected.z) && (projected.z <= projected.w)){
                // projection is within window
                const vec2 coords = (projected.xy/projected.w * .5f + .5f) * camera.resolution;

                // compare depth now as float
                const float depth = projected.w;

                const float storedDepth = uintBitsToFloat(imageLoad(depthBuffer, ivec2(coords)).x);

                if(depth <= storedDepth * 1.01){
                    // store 32-bit color to 64-bit variable to avoid overflow
                    // add 8 more bit to each channel
                    // alpha channel is used as a counter
                    uint rgba = pointsRgba[k];
                    uint r = (rgba & 0xFF);
                    uint g = (rgba >> 8) & 0xFF;
                    uint b = (rgba >> 16) & 0xFF;
                    uint64_t rgba64 = (uint64_t(r) << 48) | (uint64_t(g) << 32) | (uint64_t(b) << 16) | 1;

	                atomicAdd(renderTarget[getPixelID(camera.resolution, uvec2(coords))], rgba64);
                }
            }
        }
    }
}