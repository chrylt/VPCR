#version 460

struct AABB{
    float minX;
    float minY;
    float minZ;
    float maxX;
    float maxY;
    float maxZ;
};

struct Node{
    AABB box;
    uint childrenPointer;
    uint pointOffset;
    uint maskDepthCount;  // higher 19 bits are the count, lower 8 the child mask, middle 5 the tree depth
};

layout(set = 0, binding = 0) uniform Camera{
    mat4 view;
    mat4 projection;
    vec3 direction;
    vec3 position;
    uvec2 resolution;
}camera;

layout(set = 0, binding = 1) uniform DynamicConst{
    uint totalBatchCount;
    float lodExtend;
};

layout(set = 1, binding = 0) readonly buffer BatchNodes{
    Node nodes[];  
};

layout(set = 1, binding = 1) buffer BatchList{
    uint batchCount;
    uint batchList[];
};

layout(local_size_x = 1024) in;

// Taken from https://www.shadertoy.com/view/ssyyDh
float cbrt(const float x)
{
    float y = uintBitsToFloat(709973695u+floatBitsToUint(x)/3u);
    y = y*(2.0/3.0) + (1.0/3.0)*x/(y*y);
    y = y*(2.0/3.0) + (1.0/3.0)*x/(y*y);
    return y;
}

void main(){
    const uint id = gl_GlobalInvocationID.x;
    if (id >= totalBatchCount){
        return;
    }
    
    // TODO: traverse tree instead of processing all nodes
    const Node batchNode = nodes[id];
    
    const vec3[8] aabbCorners = vec3[](
        vec3(batchNode.box.minX, batchNode.box.minY, batchNode.box.minZ), // 0 - minimum
        vec3(batchNode.box.minX, batchNode.box.minY, batchNode.box.maxZ), // 0 0 1 -> 1
        vec3(batchNode.box.minX, batchNode.box.maxY, batchNode.box.minZ), // 0 1 0 -> 2
        vec3(batchNode.box.minX, batchNode.box.maxY, batchNode.box.maxZ), // 0 1 1 -> 3
        vec3(batchNode.box.maxX, batchNode.box.minY, batchNode.box.minZ), // 1 0 0 -> 4
        vec3(batchNode.box.maxX, batchNode.box.minY, batchNode.box.maxZ), // 1 0 1 -> 5
        vec3(batchNode.box.maxX, batchNode.box.maxY, batchNode.box.minZ), // 1 1 0 -> 6
        vec3(batchNode.box.maxX, batchNode.box.maxY, batchNode.box.maxZ)  // 7 - maximum
    );
    
    bool isVisible = false;
    for (uint i = 0; i < 8; ++i) {
        vec4 corner = camera.projection * camera.view * vec4(aabbCorners[i], 1);
        if((-corner.w <= corner.x) && (corner.x <= corner.w) &&
            (-corner.w <= corner.y) && (corner.y <= corner.w) &&
            (0.f <= corner.z) && (corner.z <= corner.w)){
            isVisible = true;
        }
    }
    
    // Frustum culling
    if (isVisible){
        // Find aabb extend on screen
        uvec2 screenMin = camera.resolution;
        uvec2 screenMax = uvec2(0);

        for(uint i = 0; i < 8; ++i){
            // Transform aabb & perspective divide
            const vec4 divReady = camera.projection * camera.view * vec4(aabbCorners[i], 1);
            const vec2 divided = (divReady / abs(divReady.w)).xy;
            const vec2 pixelSpace = ((divided + 1) / 2) * camera.resolution;

            screenMin = ivec2(min(screenMin.x, pixelSpace.x), min(screenMin.y, pixelSpace.y));
            screenMax = ivec2(max(screenMax.x, pixelSpace.x), max(screenMax.y, pixelSpace.y));
        }

        const uint pixelExtend = max(screenMax.x - screenMin.x, screenMax.y - screenMin.y);

        // LOD selection
        if (pixelExtend > lodExtend){
            const uint currentBatchCount = atomicAdd(batchCount, 1);
            batchList[currentBatchCount] = id;
        }
    }
}