#version 460
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_KHR_vulkan_glsl : enable

struct Point{
    vec3 position;
    uint rgba;
};

struct AABB{
    float minX;
    float minY;
    float minZ;
    float maxX;
    float maxY;
    float maxZ;
};

struct Node{
    AABB box;
    uint childrenPointer;
    uint pointOffset;
    uint maskDepthCount;  // higher 19 bits are the count, lower 8 the child mask, middle 5 the tree depth
};

layout(set = 0, binding = 0) uniform Camera{
    mat4 view;
    mat4 projection;
    vec3 direction;
    vec3 position;
    uvec2 resolution;
}camera;

layout(set = 0, binding = 1) uniform DynamicConst{
    uint workerCount;
};

layout(set = 1, binding = 0, r32ui) uniform uimage2D renderTarget;
layout(set = 1, binding = 1, r32ui) uniform uimage2D depthBuffer;

layout(set = 2, binding = 0) readonly buffer Points{
    Point points[];
};

layout(set = 3, binding = 0) readonly buffer BatchNodes{
    Node nodes[];  
};

layout(set = 3, binding = 1) readonly buffer BatchList{
    uint batchCount;
    uint batchList[];
};

layout(local_size_x = 128) in;

void main(){
    // TODO: @Chrylt

    const uint id = gl_GlobalInvocationID.x;
    if (id >= workerCount){
        return;
    }

    uint workAmount = batchCount / workerCount;
    const uint workOffset = workAmount * id;
    if (id == workerCount - 1){
        workAmount = batchCount - workAmount * workerCount;
    }
    
    for (uint i = workOffset; i < workOffset + workAmount; ++i){
        const Node batchNode = nodes[batchList[i]];
        for (uint k = batchNode.pointOffset; k < batchNode.pointOffset + (batchNode.maskDepthCount >> 13); ++k){

            const vec4 projected = camera.projection * camera.view * vec4(points[k].position, 1);

            if((-projected.w <= projected.x) && (projected.x <= projected.w) &&
                    (-projected.w <= projected.y) && (projected.y <= projected.w) &&
                    (0.f <= projected.z) && (projected.z <= projected.w)){
                // projection is within window
                const vec2 coords = (projected.xy/projected.w * .5f + .5f) * camera.resolution;

                // depth test via 64-bit-atomicMin
                const uint depth = floatBitsToUint(projected.w);

                const uint oldValue = imageAtomicMin(depthBuffer, ivec2(coords), depth);

                if(depth < oldValue){
	                imageAtomicExchange(renderTarget, ivec2(coords), points[k].rgba);
                }
            }
        }
    }
}