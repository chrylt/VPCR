#version 460
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_KHR_vulkan_glsl : enable

struct Point{
    vec3 position;
    uint rgba;
};

struct AABB{
    vec3 minV;
    vec3 maxV;
};

struct Batch{
    AABB box;
    uint pointOffset;
    uint pointCount;
};

layout(set = 0, binding = 0) uniform Camera{
    mat4 view;
    mat4 projection;
    vec3 direction;
    vec3 position;
    uvec2 resolution;
}camera;

layout(set = 0, binding = 1) uniform DynamicConst{
    uint workerCount;
};

layout(set = 1, binding = 0, r32ui) uniform uimage2D renderTarget;
layout(set = 1, binding = 1, r32ui) uniform uimage2D depthBuffer;

layout(set = 2, binding = 0) readonly buffer Points_Position_low_Precision{
    uint pointsPosLow[];
};

layout(set = 2, binding = 1) readonly buffer Points_Position_medium_Precision{
    uint pointsPosMedium[];
};

layout(set = 2, binding = 2) readonly buffer Points_Position_high_Precision{
    uint pointsPosHigh[];
};

layout(set = 2, binding = 3) readonly buffer Points_Color{
    uint pointsRgba[];
};

layout(set = 3, binding = 0) readonly buffer Batches{
    Batch batches[];  
};

layout(set = 3, binding = 1) readonly buffer BatchList{
    uint batchCount;
    uint batchList[];
};

layout(local_size_x = 128) in;

vec3 getPointPosition(Batch currBatch, uint pointIdx){
    // TODO
    // determine precision by projecting batch aabb to screen
    const vec4 projMinV = camera.projection * camera.view * vec4(currBatch.box.minV , 1);
    const vec4 projMaxV = camera.projection * camera.view * vec4(currBatch.box.maxV , 1);

    return vec3(0);
}

uint getPointColor(uint idx){
    return pointsRgba[idx];
}

void main(){

    const uint id = gl_GlobalInvocationID.x;
    if (id >= workerCount){
        return;
    }

    uint workAmount = batchCount / workerCount;
    const uint workOffset = workAmount * id;
    if (id == workerCount - 1){
        workAmount = batchCount - workAmount * workerCount;
    }
    
    for (uint i = workOffset; i < workOffset + workAmount; ++i){
        const Batch batch = batches[batchList[i]];
        for (uint k = batch.pointOffset; k < batch.pointOffset + batch.pointCount; ++k){

            const vec4 projected = camera.projection * camera.view * vec4(getPointPosition(batch, k), 1);

            if((-projected.w <= projected.x) && (projected.x <= projected.w) &&
                    (-projected.w <= projected.y) && (projected.y <= projected.w) &&
                    (0.f <= projected.z) && (projected.z <= projected.w)){
                // projection is within window
                const vec2 coords = (projected.xy/projected.w * .5f + .5f) * camera.resolution;

                // depth test via 64-bit-atomicMin
                const uint depth = floatBitsToUint(projected.w);

                const uint oldValue = imageAtomicMin(depthBuffer, ivec2(coords), depth);

                if(depth < oldValue){
	                imageAtomicExchange(renderTarget, ivec2(coords), getPointColor(k));
                }
            }
        }
    }
}