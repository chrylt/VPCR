#version 460
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_KHR_vulkan_glsl : enable
#include "utility_common.glsl"
#include "vertex_precision_common.glsl"

layout(set = 0, binding = 0) uniform Camera{
    mat4 view;
    mat4 projection;
    vec3 direction;
    vec3 position;
    uvec2 resolution;
}camera;

layout(set = 0, binding = 1) uniform DynamicConst{
    uint workerCount;
    uint depthDiscSteps;
};

layout(set = 1, binding = 0) buffer RENDER_TARGET{
    uint64_t renderTarget[];
};

layout(set = 1, binding = 1) buffer DEPTH_BUFFER{ 
    Histogram depthBuffer[];
};

// Vertex Precision Buffers are in vertex_precision_common file

layout(set = 2, binding = 3) buffer Points_Color{
    uint pointsRgba[];
};

layout(set = 3, binding = 0) readonly buffer Batches{
    Batch batches[];  
};

layout(set = 3, binding = 1) readonly buffer BatchList{
    uint batchCount;
    uint batchList[];
};

layout(local_size_x = 128) in;

uint getBucketIDFromDepth(const float depth){
    // depth should be in range [0, 1]
    return uint(depth * depthDiscSteps);
};

void main(){

    const uint id = gl_GlobalInvocationID.x;
    if (id >= workerCount){
        return;
    }

    const uint workAmount = uint(ceil(float(batchCount) / workerCount));
    const uint workOffset = workAmount * id;

    for (uint i = workOffset; i < workOffset + workAmount; ++i){
        if (i >= batchCount){
            continue;
        }
        const Batch batch = batches[batchList[i]];
        const vec3 batchBBSize = batch.box.maxV - batch.box.minV;
        const uint batchPixelExtend = getBatchPixelExtend(batch, camera.resolution, camera.projection, camera.view);

        for (uint k = batch.pointOffset; k < batch.pointOffset + batch.pointCount; ++k){

            const vec4 projected = camera.projection * camera.view * vec4(getAdaptivePointPosition(batchBBSize, batch.box.minV, batchPixelExtend, k), 1);

            if((-projected.w <= projected.x) && (projected.x <= projected.w) &&
                    (-projected.w <= projected.y) && (projected.y <= projected.w) &&
                    (0.f <= projected.z) && (projected.z <= projected.w)){
                // projection is within window
                const vec2 coords = (projected.xy/projected.w * .5f + .5f) * camera.resolution;

                // add point to depth histogram
                const float depth = projected.z / abs(projected.w);
                const uint bucketID = getBucketIDFromDepth(depth);
                const uint pixelID = getPixelID(camera.resolution, uvec2(coords));

                // convert color
                /// store 32-bit color to 64-bit variable to avoid overflow
                /// add 8 more bit to each channel
                /// alpha channel is used as a counter
                uint rgba = pointsRgba[k];
                uint r = (rgba & 0xFF);
                uint g = (rgba >> 8) & 0xFF;
                uint b = (rgba >> 16) & 0xFF;
                uint64_t rgba64 = (uint64_t(r) << 48) | (uint64_t(g) << 32) | (uint64_t(b) << 16) | 1;

                bool finishedInsertPoint = false;

                while(!finishedInsertPoint){ // try to insert point until it worked
                    // look for bucket to add to
                    int currIdx = depthBuffer[pixelID].startIdx;
                    int nextIdx = depthBuffer[pixelID].buckets[currIdx].nextIdx;

                    // check for insert as first
                    if(bucketID < depthBuffer[pixelID].buckets[currIdx].bucketID 
                        || currIdx == -1){  // assert(currIdx == startIdx)
                        // bucket should be inserted as new first bucket
	                    /// allocate new bucket
                        uint newIdx = atomicAdd(depthBuffer[pixelID].bucketCount, 1);
                        depthBuffer[pixelID].buckets[newIdx].bucketID = bucketID;
                        depthBuffer[pixelID].buckets[newIdx].nextIdx = currIdx;
                        depthBuffer[pixelID].buckets[newIdx].acc = rgba64;

                        /// change references to point to new bucket
                        uint oldValue = atomicCompSwap(depthBuffer[pixelID].startIdx, currIdx, newIdx); 
                        if(oldValue == currIdx){
                            // insertion worked
                            finishedInsertPoint = true;
                        }
                    }

                    bool insertFailed = false;
                    while(!finishedInsertPoint && !insertFailed && currIdx != -1){

                        if(depthBuffer[pixelID].buckets[currIdx].bucketID == bucketID){
                            // found fitting bucket - add contribution
	                        atomicAdd(depthBuffer[pixelID].buckets[currIdx].acc, rgba64);
                            finishedInsertPoint = true;
                        }

                        if(depthBuffer[pixelID].buckets[currIdx].bucketID < bucketID 
                            && bucketID < depthBuffer[pixelID].buckets[nextIdx].bucketID){
                            // insert between buckets
                            /// allocate new bucket
                            uint newIdx = atomicAdd(depthBuffer[pixelID].bucketCount, 1);
                            depthBuffer[pixelID].buckets[newIdx].bucketID = bucketID;
                            depthBuffer[pixelID].buckets[newIdx].nextIdx = nextIdx;
                            depthBuffer[pixelID].buckets[newIdx].acc = rgba64;

                            /// change references to point to new bucket
                            uint oldValue = atomicCompSwap(depthBuffer[pixelID].buckets[currIdx].nextIdx, nextIdx, newIdx); 
                            if(oldValue == nextIdx){
                                finishedInsertPoint = true;
                            }else{
                                insertFailed = true;
                            }
                        }

                        // check for insert as last
                        if(depthBuffer[pixelID].buckets[currIdx].bucketID < bucketID 
                            && depthBuffer[pixelID].buckets[nextIdx].bucketID == -1){  // assert(currIdx == startIdx)
                            // bucket should be inserted as new first bucket
	                        /// allocate new bucket
                            uint newIdx = atomicAdd(depthBuffer[pixelID].bucketCount, 1);
                            depthBuffer[pixelID].buckets[newIdx].bucketID = bucketID;
                            depthBuffer[pixelID].buckets[newIdx].nextIdx = -1;
                            depthBuffer[pixelID].buckets[newIdx].acc = rgba64;

                            /// change references to point to new bucket
                            uint oldValue = atomicCompSwap(depthBuffer[pixelID].startIdx, currIdx, newIdx); 
                            if(oldValue == currIdx){
                                // insertion worked
                                finishedInsertPoint = true;
                            }else{
                                insertFailed = true;
                            }
                        }
                    }
                }
            }
        }
    }
}