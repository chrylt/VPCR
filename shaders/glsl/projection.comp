#version 460
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_KHR_vulkan_glsl : enable

struct Point{
    vec3 position;
    uint rgba;
};

struct AABB{
    vec3 minV;
    vec3 maxV;
};

struct Batch{
    AABB box;
    uint pointOffset;
    uint pointCount;
};

layout(set = 0, binding = 0) uniform Camera{
    mat4 view;
    mat4 projection;
    vec3 direction;
    vec3 position;
    uvec2 resolution;
}camera;

layout(set = 0, binding = 1) uniform DynamicConst{
    uint workerCount;
};

layout(set = 1, binding = 0, r32ui) uniform uimage2D renderTarget;
layout(set = 1, binding = 1, r32ui) uniform uimage2D depthBuffer;

layout(set = 2, binding = 0) readonly buffer Points_Position_low_Precision{
    uint pointsPosLow[];
};

layout(set = 2, binding = 1) readonly buffer Points_Position_medium_Precision{
    uint pointsPosMedium[];
};

layout(set = 2, binding = 2) readonly buffer Points_Position_high_Precision{
    uint pointsPosHigh[];
};

layout(set = 2, binding = 3) buffer Points_Color{
    uint pointsRgba[];
};

layout(set = 3, binding = 0) readonly buffer Batches{
    Batch batches[];  
};

layout(set = 3, binding = 1) readonly buffer BatchList{
    uint batchCount;
    uint batchList[];
};

layout(local_size_x = 128) in;

vec3 getPointPosition(const Batch currBatch, const uint pointIdx){

    // determine precision by projecting batch aabb to screen
        // create aabb corner points
    const vec3[8] aabbCorners = vec3[](
        currBatch.box.minV, // 0 - minimum
        vec3(currBatch.box.minV.x, currBatch.box.minV.y, currBatch.box.maxV.z), // 0 0 1 -> 1
        vec3(currBatch.box.minV.x, currBatch.box.maxV.y, currBatch.box.minV.z), // 0 1 0 -> 2
        vec3(currBatch.box.minV.x, currBatch.box.maxV.y, currBatch.box.maxV.z), // 0 1 1 -> 3
        vec3(currBatch.box.maxV.x, currBatch.box.minV.y, currBatch.box.minV.z), // 1 0 0 -> 4
        vec3(currBatch.box.maxV.x, currBatch.box.minV.y, currBatch.box.maxV.z), // 1 0 1 -> 5
        vec3(currBatch.box.maxV.x, currBatch.box.maxV.y, currBatch.box.minV.z), // 1 1 0 -> 6
        currBatch.box.maxV  // 7 - maximum
    );

        // find aabb extend on screen
    uvec2 screenMin = camera.resolution;    // theoretically not ideal at edges!
    uvec2 screenMax = uvec2(0);             // 

    for(uint i=0; i < 8; i++){
        // transform aabb & perspective divide
        const vec4 divReady = camera.projection * camera.view * vec4(aabbCorners[i], 1);
        const vec2 divided = (divReady / abs(divReady.w)).xy;
        const vec2 pixelSpace = ((divided + 1) / 2) * camera.resolution;

        screenMin = uvec2(min(screenMin.x, pixelSpace.x), min(screenMin.y, pixelSpace.y));
        screenMax = uvec2(max(screenMax.x, pixelSpace.x), max(screenMax.y, pixelSpace.y));
    }

    const uint pixelExtend = max(screenMax.x - screenMin.x, screenMax.y - screenMin.y);

    // create coordinate at precision level
    const vec3 boxSize = currBatch.box.maxV - currBatch.box.minV;
    vec3 resultPosition = currBatch.box.minV;

        // low precision
    const uint encodedLow = pointsPosLow[pointIdx];
    const vec3 offsetLow = vec3(encodedLow & 0x3FF, (encodedLow >> 10) & 0x3FF, (encodedLow >> 20) & 0x3FF) / (1 << 10) * boxSize;
    resultPosition += offsetLow;

    if(pixelExtend > 512) {
        // add medium precision
        const uint encodedMedium = pointsPosMedium[pointIdx];
        const vec3 offsetMedium = vec3(encodedMedium & 0x3FF, (encodedMedium >> 10) & 0x3FF, (encodedMedium >> 20) & 0x3FF) / (1 << 20) * boxSize;
        resultPosition += offsetMedium;
    }

    if(pixelExtend > 524288) {  // We will probably never need this. Do we leave this here or delete (along with buffer for it)?
        // add high precision
        const uint encodedHigh = pointsPosHigh[pointIdx];
        const vec3 offsetHigh = vec3(encodedHigh & 0x3FF, (encodedHigh >> 10) & 0x3FF, (encodedHigh >> 20) & 0x3FF) / (1 << 30) * boxSize;
        resultPosition += offsetHigh;
    }

    return resultPosition;
}

uint getPointColor(uint idx){
    return pointsRgba[idx];
}

void main(){

    const uint id = gl_GlobalInvocationID.x;
    if (id >= workerCount){
        return;
    }

    uint workAmount = batchCount / workerCount;
    const uint workOffset = workAmount * id;
    if (id == workerCount - 1){
        workAmount = batchCount - workAmount * workerCount;
    }
    
    for (uint i = workOffset; i < workOffset + workAmount; ++i){
        const Batch batch = batches[batchList[i]];
        for (uint k = batch.pointOffset; k < batch.pointOffset + batch.pointCount; ++k){

            const vec4 projected = camera.projection * camera.view * vec4(getPointPosition(batch, k), 1);

            if((-projected.w <= projected.x) && (projected.x <= projected.w) &&
                    (-projected.w <= projected.y) && (projected.y <= projected.w) &&
                    (0.f <= projected.z) && (projected.z <= projected.w)){
                // projection is within window
                const vec2 coords = (projected.xy/projected.w * .5f + .5f) * camera.resolution;

                // depth test via 64-bit-atomicMin
                const uint depth = floatBitsToUint(projected.w);

                const uint oldValue = imageAtomicMin(depthBuffer, ivec2(coords), depth);

                if(depth < oldValue){
	                imageAtomicExchange(renderTarget, ivec2(coords), getPointColor(k));
                }
            }
        }
    }
}